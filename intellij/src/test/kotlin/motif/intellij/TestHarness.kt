/*
 * Copyright (c) 2018-2019 Uber Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package motif.intellij

import com.google.common.truth.Truth.assertThat
import com.google.common.truth.Truth.assertWithMessage
import com.intellij.openapi.projectRoots.impl.JavaAwareProjectJdkTableImpl
import com.intellij.testFramework.Parameterized
import com.intellij.testFramework.PsiTestUtil
import com.intellij.testFramework.fixtures.DefaultLightProjectDescriptor
import com.intellij.testFramework.fixtures.LightJavaCodeInsightFixtureTestCase
import java.io.File
import java.net.URI
import javax.annotation.Nullable
import javax.inject.Inject
import kotlin.reflect.KClass
import motif.Scope
import motif.core.ResolvedGraph
import motif.errormessage.ErrorMessage
import motif.intellij.testing.IntelliJRule
import motif.viewmodel.TestRenderer
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(Parameterized::class)
class TestHarness : LightJavaCodeInsightFixtureTestCase() {

  @get:Rule val rule = IntelliJRule()

  @org.junit.runners.Parameterized.Parameter(0) lateinit var testDir: File

  override fun getProjectDescriptor() = DefaultLightProjectDescriptor {
    JavaAwareProjectJdkTableImpl.getInstanceEx().internalJdk
  }

  @Before
  public override fun setUp() {
    super.setUp()

    addLibrary(Inject::class)
    addLibrary(Scope::class)
    addLibrary(Nullable::class)
  }

  @After
  public override fun tearDown() {
    super.tearDown()
  }

  private fun addLibrary(clazz: KClass<*>) {
    val fileUri =
        clazz
            .java
            .getResource(clazz.simpleName + ".class")
            ?.toString()
            ?.let { Regex("file:.*[.]jar").find(it)?.value }
            ?.let { URI.create(it) }
    if (fileUri != null) {
      val file = File(fileUri)
      val libName = file.name
      PsiTestUtil.addLibrary(myFixture.projectDisposable, module, libName, file.parent, libName)
    }
  }

  @Test
  fun test() {
    val testFiles = testDir.walk()
    val externalFiles = EXTERNAL_ROOT.resolve(testDir.name).walk()
    (testFiles + externalFiles).filter { !it.isDirectory }.forEach { sourceFile ->
      when {
        sourceFile.name.endsWith(".java") -> myFixture.addClass(sourceFile.readText())
        sourceFile.name.endsWith(".kt") ->
            myFixture.addFileToProject(sourceFile.name, sourceFile.readText())
      }
    }
    val graph = GraphFactory(project).compute()

    val errorFile = testDir.resolve("ERROR.txt")
    if (errorFile.exists()) {
      val expectedErrorText = errorFile.readText()
      val actualErrorText = getActualErrorString(graph)
      assertThat(actualErrorText).isEqualTo(expectedErrorText)
    } else if (graph.errors.isNotEmpty()) {
      val errorText = getActualErrorString(graph)
      assertWithMessage("Expected valid graph but errors found:\n\n$errorText").fail()
    }

    val graphFile = testDir.resolve("GRAPH.txt")
    if (graphFile.exists()) {
      val expectedGraphText = graphFile.readText()
      val actualGraphText = getActualGraphString(graph)
      assertThat(actualGraphText).isEqualTo(expectedGraphText)
    }
  }

  // TODO Some of this code is duplicated in the compiler TestHarness. Move both test harnesses into
  // the
  //      same module so they can share code.
  private fun getActualGraphString(graph: ResolvedGraph): String {
    val message = TestRenderer.render(graph)
    val header =
        """########################################################################
#                                                                      #
# This file is auto-generated by running the Motif compiler tests and  #
# serves a as validation of graph correctness. IntelliJ plugin tests   #
# also rely on this file to ensure that the plugin graph understanding #
# is equivalent to the compiler's.                                     #
#                                                                      #
# - Do not edit manually.                                              #
# - Commit changes to source control.                                  #
# - Since this file is autogenerated, code review changes carefully to #
#   ensure correctness.                                                #
#                                                                      #
########################################################################
"""
    return header + "\n" + message + "\n"
  }

  private fun getActualErrorString(graph: ResolvedGraph): String {
    val header =
        """########################################################################
#                                                                      #
# This file is auto-generated by running the Motif compiler tests and  #
# serves both as validation of error correctness and as a record of    #
# the current compiler error output.                                   #
#                                                                      #
# - Do not edit manually.                                              #
# - Commit changes to source control.                                  #
# - Since this file is autogenerated, code review changes carefully to #
#   ensure correctness.                                                #
#                                                                      #
########################################################################
"""
    val message = ErrorMessage.toString(graph).trim().prependIndent("  ")
    return header + "\n" + message + "\n"
  }

  override fun getTestDataPath() = testDir.parent

  companion object {

    private val SOURCE_ROOT = File("../tests/src/main/java/")
    private val TEST_CASE_ROOT = File(SOURCE_ROOT, "testcases")
    private val EXTERNAL_ROOT = File(SOURCE_ROOT, "external")

    @Parameterized.Parameters(name = "{0}")
    @JvmStatic
    fun data(clazz: Class<*>): List<Array<Any>> {
      val testDirs = TEST_CASE_ROOT.listFiles() ?: throw IllegalStateException()
      return testDirs.filter { !it.resolve("SKIP_INTELLIJ").exists() }.map { testDir ->
        arrayOf<Any>(testDir)
      }
    }

    @org.junit.runners.Parameterized.Parameters
    @JvmStatic
    fun ignore(): List<Array<Any>> = emptyList()
  }
}
