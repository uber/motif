/*
 * Copyright (c) 2018-2019 Uber Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package motif.intellij

import com.google.common.truth.Truth.assertThat
import com.intellij.openapi.projectRoots.Sdk
import com.intellij.openapi.projectRoots.impl.JavaAwareProjectJdkTableImpl
import com.intellij.pom.java.LanguageLevel
import com.intellij.testFramework.LightProjectDescriptor
import com.intellij.testFramework.Parameterized
import com.intellij.testFramework.PsiTestUtil
import com.intellij.testFramework.fixtures.LightCodeInsightFixtureTestCase
import motif.Scope
import motif.core.ResolvedGraph
import motif.errormessage.ErrorMessage
import motif.intellij.testing.IntelliJRule
import motif.intellij.testing.InternalJdk
import motif.viewmodel.TestRenderer
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import java.io.File
import javax.annotation.Nullable
import javax.inject.Inject
import kotlin.reflect.KClass

@RunWith(Parameterized::class)
class TestHarness : LightCodeInsightFixtureTestCase() {

    @get:Rule val rule = IntelliJRule()

    @org.junit.runners.Parameterized.Parameter(0)
    lateinit var testDir: File

    override fun getProjectDescriptor(): LightProjectDescriptor {
        return object : ProjectDescriptor(LanguageLevel.HIGHEST) {
            override fun getSdk() = InternalJdk.instance
        }
    }

    @Before
    public override fun setUp() {
        super.setUp()

        addLibrary(Inject::class)
        addLibrary(Scope::class)
        addLibrary(Nullable::class)
    }

    @After
    public override fun tearDown() {
        super.tearDown()
    }

    private fun addLibrary(clazz: KClass<*>) {
        val path = clazz.java.protectionDomain.codeSource.location.path
        val file = File(path)
        val libName = file.name
        PsiTestUtil.addLibrary(myFixture.projectDisposable, myModule, libName, file.parent, libName)
    }

    @Test
    fun test() {
        val testFiles = testDir.walk()
        val externalFiles = EXTERNAL_ROOT.resolve(testDir.name).walk()
        (testFiles + externalFiles)
                .filter { !it.isDirectory && it.name.endsWith(".java") }
                .forEach { sourceFile ->
                    myFixture.addClass(sourceFile.readText())
                }
        val graph = GraphFactory(project).compute()

        val graphFile = testDir.resolve("GRAPH.txt")
        if (graphFile.exists()) {
            val expectedGraphText = graphFile.readText()
            val actualGraphText = getActualGraphString(graph)
            assertThat(actualGraphText).isEqualTo(expectedGraphText)
        }

        val errorFile = testDir.resolve("ERROR.txt")
        if (errorFile.exists()) {
            val expectedErrorText = errorFile.readText()
            val actualErrorText = getActualErrorString(graph)
            assertThat(actualErrorText).isEqualTo(expectedErrorText)
        }
    }

    // TODO Some of this code is duplicated in the compiler TestHarness. Move both test harnesses into the
    //      same module so they can share code.
    private fun getActualGraphString(graph: ResolvedGraph): String {
        val message = TestRenderer.render(graph)
        val header ="""########################################################################
#                                                                      #
# This file is auto-generated by running the Motif compiler tests and  #
# serves a as validation of graph correctness. IntelliJ plugin tests   #
# also rely on this file to ensure that the plugin graph understanding #
# is equivalent to the compiler's.                                     #
#                                                                      #
# - Do not edit manually.                                              #
# - Commit changes to source control.                                  #
# - Since this file is autogenerated, code review changes carefully to #
#   ensure correctness.                                                #
#                                                                      #
########################################################################
"""
        return header + "\n" + message + "\n"
    }

    private fun getActualErrorString(graph: ResolvedGraph): String {
        val header = """########################################################################
#                                                                      #
# This file is auto-generated by running the Motif compiler tests and  #
# serves both as validation of error correctness and as a record of    #
# the current compiler error output.                                   #
#                                                                      #
# - Do not edit manually.                                              #
# - Commit changes to source control.                                  #
# - Since this file is autogenerated, code review changes carefully to #
#   ensure correctness.                                                #
#                                                                      #
########################################################################
"""
        val message = ErrorMessage.toString(graph).trim().prependIndent("  ")
        return header + "\n" + message + "\n"
    }

    override fun getTestDataPath() = testDir.parent

    companion object {

        private val SOURCE_ROOT = File("../tests/src/main/java/")
        private val TEST_CASE_ROOT = File(SOURCE_ROOT, "testcases")
        private val EXTERNAL_ROOT = File(SOURCE_ROOT, "external")

        @Parameterized.Parameters(name = "{0}")
        @JvmStatic
        fun data(clazz: Class<*>): List<Array<Any>> {
            val testDirs = TEST_CASE_ROOT.listFiles() ?: throw IllegalStateException()
            return testDirs
                    .filter { !it.resolve("SKIP_INTELLIJ").exists() }
                    .map { testDir ->
                        arrayOf<Any>(testDir)
                    }
        }

        @org.junit.runners.Parameterized.Parameters
        @JvmStatic
        fun ignore(): List<Array<Any>> = emptyList()
    }
}
