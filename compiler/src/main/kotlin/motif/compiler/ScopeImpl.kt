/*
 * Copyright (c) 2018-2019 Uber Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package motif.compiler

import androidx.room.compiler.processing.XProcessingEnv
import androidx.room.compiler.processing.XType
import androidx.room.compiler.processing.compat.XConverters.getProcessingEnv
import androidx.room.compiler.processing.compat.XConverters.toJavac
import androidx.room.compiler.processing.compat.XConverters.toKS
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.WildcardTypeName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.STAR
import com.squareup.kotlinpoet.jvm.jvmSuppressWildcards
import com.squareup.kotlinpoet.jvm.jvmWildcard
import motif.ast.compiler.CompilerAnnotation
import motif.ast.compiler.CompilerMethod

/**
 * Code generation model. Serves as an intermediate representation of the code generated by the
 * annotation processor. This allows us to share the [ScopeImplFactory] logic across Java and Kotlin
 * implementations.
 */
class ScopeImpl(
    val useNullFieldInitialization: Boolean,
    val className: ClassName,
    val superClassName: ClassName,
    val internalScope: Boolean,
    val scopeImplAnnotation: ScopeImplAnnotation,
    val objectsField: ObjectsField?,
    val dependenciesField: DependenciesField,
    val cacheFields: List<CacheField>,
    val constructor: Constructor,
    val alternateConstructor: AlternateConstructor?,
    val accessMethodImpls: List<AccessMethodImpl>,
    val childMethodImpls: List<ChildMethodImpl>,
    val scopeProviderMethod: ScopeProviderMethod,
    val factoryProviderMethods: List<FactoryProviderMethod>,
    val dependencyProviderMethods: List<DependencyProviderMethod>,
    val objectsImpl: ObjectsImpl?,
    val dependencies: Dependencies?,
)

/**
 * ```
 * @ScopeImpl(
 *     children = { Child.class },
 *     scope = FooScope.class,
 *     dependencies = FooScopeImpl.Dependencies.class
 * )
 * ```
 */
class ScopeImplAnnotation(
    val children: List<ClassName>,
    val scopeClassName: ClassName,
    val dependenciesClassName: ClassName,
)

/**
 * ```
 * private final FooScope.Objects objects = new Objects();
 * ```
 */
class ObjectsField(
    val objectsClassName: ClassName,
    val objectsImplClassName: ClassName,
    val name: String,
)

/**
 * ```
 * private final Dependencies dependencies;
 * ```
 */
class DependenciesField(val dependenciesClassName: ClassName, val name: String)

/**
 * ```
 * private Object foo = None.NONE;
 * ```
 */
class CacheField(val name: String)

/**
 * ```
 * public FooScopeImpl(FooScopeImpl.Dependencies dependencies) {
 *     this.dependencies = dependencies;
 * }
 * ```
 */
class Constructor(
    val dependenciesClassName: ClassName,
    val dependenciesParameterName: String,
    val dependenciesFieldName: String,
)

/**
 * ```
 * public FooScopeImpl() {
 *     this(new FooScopeImpl.Dependencies() {});
 * }
 * ```
 */
class AlternateConstructor(val dependenciesClassName: ClassName)

/**
 * ```
 * @Override
 * public Foo foo() {
 *   return foo2();
 * }
 * ```
 */
class AccessMethodImpl(
    // Required work around https://github.com/square/javapoet/issues/656
    val env: XProcessingEnv,
    val overriddenMethod: CompilerMethod,
    val providerMethodName: String,
)

/**
 * ```
 * @Override
 * public ChildScope childScope([ ChildMethpdImplParameters ]) {
 *   return new ChildScopeImpl([ ChildDependenciesImpl ]);
 * }
 * ```
 */
class ChildMethodImpl(
    val childClassName: ClassName,
    val childImplClassName: ClassName,
    val childMethodName: String,
    val parameters: List<ChildMethodImplParameter>,
    val childDependenciesImpl: ChildDependenciesImpl,
)

/**
 * ```
 * final Foo foo
 * ```
 */
class ChildMethodImplParameter(val typeName: TypeName, val name: String)

/**
 * ```
 * new ChildScopeImpl.Dependencies() {
 *
 *     [ ChildDependencyMethodImpls ]
 * }
 * ```
 */
class ChildDependenciesImpl(
    val childDependenciesClassName: ClassName,
    val methods: List<ChildDependencyMethodImpl>,
    val isAbstractClass: Boolean,
    val env: XProcessingEnv,
)

/**
 * ```
 * @Override
 * Foo foo() {
 *     [ ChildDependencyMethodImpl.ReturnExpression ]
 * }
 * ```
 */
class ChildDependencyMethodImpl(
    val name: String,
    val returnTypeName: TypeName,
    val returnExpression: ReturnExpression,
    val isInternal: Boolean,
) {

  sealed class ReturnExpression {

    /**
     * ```
     * return foo;
     * ```
     */
    class Parameter(val parameterName: String) : ReturnExpression()

    /**
     * ```
     * return ParentScopeImpl.this.bar();
     * ```
     */
    class Provider(val scopeImplName: ClassName, val providerName: String) : ReturnExpression()
  }
}

/**
 * ```
 * FooScope scope() {
 *     return this;
 * }
 * ```
 */
class ScopeProviderMethod(val name: String, val scopeClassName: ClassName, val isInternal: Boolean)

/**
 * ```
 * Foo foo() {
 *     return dependencies.foo();
 * }
 * ```
 */
class DependencyProviderMethod(
    val name: String,
    val returnTypeName: TypeName,
    val dependenciesFieldName: String,
    val dependencyMethodName: String,
    val env: XProcessingEnv,
)

/**
 * ```
 * Foo foo() {
 *     [ FactoryProviderMethodBody ]
 * }
 *
 * [ SpreadProviderMethods ]
 * ```
 */
class FactoryProviderMethod(
    val name: String,
    val returnTypeName: TypeName,
    val body: FactoryProviderMethodBody,
    val spreadProviderMethods: List<SpreadProviderMethod>,
    val env: XProcessingEnv,
)

sealed class FactoryProviderMethodBody {

  /**
   * ```
   * if (foo == None.NONE) {
   *     synchronized (this) {
   *         if (foo == None.NONE) {
   *             foo = [ FactoryProviderInstantiation ];
   *         }
   *     }
   * }
   * return (Integer) integer;
   * ```
   */
  class Cached(
      val cacheFieldName: String,
      val returnTypeName: TypeName,
      val instantiation: FactoryProviderInstantiation,
      val env: XProcessingEnv,
  ) : FactoryProviderMethodBody()

  /**
   * ```
   * return [ FactoryProviderInstantiation ];
   * ```
   */
  class Uncached(val instantiation: FactoryProviderInstantiation) : FactoryProviderMethodBody()
}

sealed class FactoryProviderInstantiation {

  /**
   * Static:
   * ```
   * Objects.foo(bar(), baz())
   * ```
   *
   * Non-static:
   * ```
   * objects.foo(bar(), baz())
   * ```
   */
  class Basic(
      val objectsFieldName: String,
      val objectsClassName: ClassName,
      val isStatic: Boolean,
      val factoryMethodName: String,
      val callProviders: CallProviders,
  ) : FactoryProviderInstantiation()

  /**
   * ```
   * new Foo(bar(), baz())
   * ```
   */
  class Constructor(val returnTypeName: TypeName, val callProviders: CallProviders) :
      FactoryProviderInstantiation()

  /**
   * ```
   * foo()
   * ```
   */
  class Binds(val providerMethodName: String) : FactoryProviderInstantiation()
}

/**
 * ```
 * (foo(), bar())
 * ```
 */
class CallProviders(val providerMethodNames: List<String>)

/**
 * ```
 * Foo foo() {
 *     return spreadable().foo();
 * }
 * ```
 */
class SpreadProviderMethod(
    val name: String,
    val isStatic: Boolean,
    val returnTypeName: TypeName,
    val sourceTypeName: TypeName,
    val sourceProviderMethodName: String,
    val spreadMethodName: String,
)

/**
 * ```
 * public interface Dependencies {
 *     [ DependencyMethods ]
 * }
 * ```
 */
class Dependencies(val className: ClassName, val methods: List<DependencyMethod>)

/**
 * ```
 * [ JavaDoc ]
 * [ Qualifier ]
 * String fooString();
 * ```
 */
class DependencyMethod(
    val name: String,
    val returnTypeName: TypeName,
    val qualifier: Qualifier?,
    val javaDoc: DependencyMethodJavaDoc,
    val internal: Boolean,
)

/**
 * ```
 * @Named("foo")
 * ```
 */
class Qualifier(val annotation: CompilerAnnotation)

/**
 * ```
 * <ul>
 * Requested from:
 * [ JavaDocMethodLinks ]
 * <ul>
 * ```
 */
class DependencyMethodJavaDoc(val requestedFrom: List<JavaDocMethodLink>)

/**
 * ```
 * <li>{@link com.example.Foo#bar(com.example.Baz) }</li>
 * ```
 */
class JavaDocMethodLink(
    val owner: String,
    val methodName: String,
    val parameterTypes: List<String>,
)

/**
 * ```
 * private static class Objects extends FooScope.Objects {
 *
 *     [ ObjectsAbstractMethods ]
 * }
 * ```
 */
class ObjectsImpl(
    val className: ClassName,
    val superClassName: ClassName,
    val isInterface: Boolean,
    val abstractMethods: List<ObjectsAbstractMethod>,
)

/**
 * ```
 * @Override
 * ConstructorDep constructorDep() {
 *     throw new UnsupportedOperationException();
 * }
 * ```
 */
class ObjectsAbstractMethod(
    // Required work around https://github.com/square/javapoet/issues/656
    val env: XProcessingEnv,
    val overriddenMethod: CompilerMethod,
)

class TypeName private constructor(private val mirror: XType) {

  val j: com.squareup.javapoet.TypeName by lazy {
    val jTypeName = mirror.typeName
    if (mirror.typeArguments.isNotEmpty() &&
        "<" !in jTypeName.toString() &&
        jTypeName is com.squareup.javapoet.ClassName) {
      ParameterizedTypeName.get(
          jTypeName,
          *mirror.typeArguments
              .map { WildcardTypeName.subtypeOf(Object::class.java) }
              .toTypedArray(),
      )
    } else if (mirror.typeArguments.isNotEmpty() &&
        "<" in jTypeName.toString() &&
        "$" in jTypeName.toString()) {
      // Work around issue where JavaPoet returns a TypeName with a '$' for a Kotlin inner class
      ParameterizedTypeName.get(
          com.squareup.javapoet.ClassName.get(mirror.typeElement?.toJavac()),
          *mirror.typeArguments.map { it.typeName }.toTypedArray(),
      )
    } else {
      jTypeName
    }
  }

  val kt: com.squareup.kotlinpoet.TypeName by lazy {
    val ktTypeName = KotlinTypeWorkaround.javaToKotlinType(mirror)
    if (mirror.typeArguments.isNotEmpty() &&
        "<" !in ktTypeName.toString() &&
        ktTypeName is com.squareup.kotlinpoet.ClassName) {
      ktTypeName.parameterizedBy(mirror.typeArguments.map { STAR })
    } else if (mirror.getProcessingEnv().backend == XProcessingEnv.Backend.KSP &&
        mirror.toKS().annotations.any {
          it.shortName.asString() == JvmSuppressWildcards::class.java.simpleName
        }) {
      ktTypeName.jvmSuppressWildcards()
    } else if (mirror.getProcessingEnv().backend == XProcessingEnv.Backend.KSP &&
        mirror.toKS().annotations.any {
          it.shortName.asString() == JvmWildcard::class.java.simpleName
        }) {
      ktTypeName.jvmWildcard()
    } else if ("<out " in ktTypeName.toString()) {
      ktTypeName.jvmSuppressWildcards()
    } else {
      ktTypeName
    }
  }

  val className: ClassName by lazy { ClassName.get(j, mirror.getProcessingEnv()) }

  companion object {

    fun get(mirror: XType): TypeName = TypeName(mirror)
  }
}

class ClassName
private constructor(
    val j: com.squareup.javapoet.ClassName,
    val env: XProcessingEnv?,
) {

  val kt: com.squareup.kotlinpoet.ClassName by lazy {
    val className =
        com.squareup.kotlinpoet.ClassName(
            j.packageName(),
            j.simpleNames().first(),
            *j.simpleNames().drop(1).toTypedArray(),
        )
    KotlinTypeWorkaround.javaToKotlinType(className, env) as com.squareup.kotlinpoet.ClassName
  }

  fun nestedClass(name: String): ClassName = ClassName(j.nestedClass(name), env)

  companion object {

    fun get(packageName: String, name: String): ClassName {
      val j = com.squareup.javapoet.ClassName.get(packageName, name)
      return ClassName(j, null)
    }

    fun get(j: com.squareup.javapoet.TypeName, env: XProcessingEnv): ClassName =
        ClassName(j as com.squareup.javapoet.ClassName, env)
  }
}
