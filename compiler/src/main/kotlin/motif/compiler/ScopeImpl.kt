/*
 * Copyright (c) 2018-2019 Uber Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package motif.compiler

import motif.ast.compiler.CompilerAnnotation
import motif.ast.compiler.CompilerMethod
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.type.TypeMirror

/**
 * Code generation model. Serves as an intermediate representation of the code generated by the annotation processor.
 * This allows us to share the [ScopeImplFactory] logic across Java and Kotlin implementations.
 */
class ScopeImpl(
        val className: ClassName,
        val superClassName: ClassName,
        val scopeImplAnnotation: ScopeImplAnnotation,
        val objectsField: ObjectsField?,
        val dependenciesField: DependenciesField,
        val cacheFields: List<CacheField>,
        val constructor: Constructor,
        val alternateConstructor: AlternateConstructor?,
        val accessMethodImpls: List<AccessMethodImpl>,
        val childMethodImpls: List<ChildMethodImpl>,
        val scopeProviderMethod: ScopeProviderMethod,
        val factoryProviderMethods: List<FactoryProviderMethod>,
        val dependencyProviderMethods: List<DependencyProviderMethod>,
        val objectsImpl: ObjectsImpl?,
        val dependencies: Dependencies)

/**
 * ```
 * @ScopeImpl(
 *     children = { Child.class },
 *     scope = FooScope.class,
 *     dependencies = FooScopeImpl.Dependencies.class
 * )
 * ```
 */
class ScopeImplAnnotation(
        val children: List<ClassName>,
        val scopeClassName: ClassName,
        val dependenciesClassName: ClassName)

/**
 * ```
 * private final FooScope.Objects objects = new Objects();
 * ```
 */
class ObjectsField(
        val objectsClassName: ClassName,
        val objectsImplClassName: ClassName,
        val name: String)

/**
 * ```
 * private final Dependencies dependencies;
 * ```
 */
class DependenciesField(
        val dependenciesClassName: ClassName,
        val name: String)

/**
 * ```
 * private Object foo = None.NONE;
 * ```
 */
class CacheField(
        val name: String)

/**
 * ```
 * public FooScopeImpl(FooScopeImpl.Dependencies dependencies) {
 *     this.dependencies = dependencies;
 * }
 * ```
 */
class Constructor(
        val dependenciesClassName: ClassName,
        val dependenciesParameterName: String,
        val dependenciesFieldName: String)

/**
 * ```
 * public FooScopeImpl() {
 *     this(new FooScopeImpl.Dependencies() {});
 * }
 * ```
 */
class AlternateConstructor(
        val dependenciesClassName: ClassName)

/**
 * ```
 * @Override
 * public Foo foo() {
 *   return foo2();
 * }
 * ```
 */
class AccessMethodImpl(
        // Required work around https://github.com/square/javapoet/issues/656
        val env: ProcessingEnvironment,
        val overriddenMethod: CompilerMethod,
        val providerMethodName: String)

/**
 * ```
 * @Override
 * public ChildScope childScope([ ChildMethpdImplParameters ]) {
 *   return [ ChildDependenciesImpl ];
 * }
 * ```
 */
class ChildMethodImpl(
        val childClassName: ClassName,
        val childImplClassName: ClassName,
        val childMethodName: String,
        val parameters: List<ChildMethodImplParameter>,
        val childDependenciesImpl: ChildDependenciesImpl)

/**
 * ```
 * final Foo foo
 * ```
 */
class ChildMethodImplParameter(
        val typeName: TypeName,
        val name: String)

/**
 * ```
 * new ChildScopeImpl.Dependencies() {
 *
 *     [ ChildDependencyMethodImpls ]
 * }
 * ```
 */
class ChildDependenciesImpl(
        val childDependenciesClassName: ClassName,
        val methods: List<ChildDependencyMethodImpl>)

/**
 * ```
 * @Override
 * Foo foo() {
 *     [ ChildDependencyMethodImpl.ReturnExpression ]
 * }
 * ```
 */
class ChildDependencyMethodImpl(
        val name: String,
        val returnTypeName: TypeName,
        val returnExpression: ReturnExpression) {

    sealed class ReturnExpression {

        /**
         * ```
         * return foo;
         * ```
         */
        class Parameter(val parameterName: String) : ReturnExpression()

        /**
         * ```
         * return ParentScopeImpl.this.bar();
         * ```
         */
        class Provider(val scopeImplName: ClassName, val providerName: String) : ReturnExpression()
    }
}

/**
 * ```
 * FooScope scope() {
 *     return this;
 * }
 * ```
 */
class ScopeProviderMethod(
        val name: String,
        val scopeClassName: ClassName)

/**
 * ```
 * Foo foo() {
 *     return dependencies.foo();
 * }
 * ```
 */
class DependencyProviderMethod(
        val name: String,
        val returnTypeName: TypeName,
        val dependenciesFieldName: String,
        val dependencyMethodName: String)

/**
 * ```
 * Foo foo() {
 *     [ FactoryProviderMethodBody ]
 * }
 *
 * [ SpreadProviderMethods ]
 * ```
 */
class FactoryProviderMethod(
        val name: String,
        val returnTypeName: TypeName,
        val body: FactoryProviderMethodBody,
        val spreadProviderMethods: List<SpreadProviderMethod>)

sealed class FactoryProviderMethodBody {

    /**
     * ```
     * if (foo == None.NONE) {
     *     synchronized (this) {
     *         if (foo == None.NONE) {
     *             foo = [ FactoryProviderInstantiation ];
     *         }
     *     }
     * }
     * return (Integer) integer;
     * ```
     */
    class Cached(
            val cacheFieldName: String,
            val returnTypeName: TypeName,
            val instantiation: FactoryProviderInstantiation) : FactoryProviderMethodBody()

    /**
     * ```
     * return [ FactoryProviderInstantiation ];
     * ```
     */
    class Uncached(
            val instantiation: FactoryProviderInstantiation) : FactoryProviderMethodBody()
}

sealed class FactoryProviderInstantiation {

    /**
     * Static:
     * ```
     * Objects.foo(bar(), baz())
     * ```
     *
     * Non-static:
     * ```
     * objects.foo(bar(), baz())
     * ```
     */
    class Basic(
            val objectsFieldName: String,
            val objectsClassName: ClassName,
            val isStatic: Boolean,
            val factoryMethodName: String,
            val callProviders: CallProviders) : FactoryProviderInstantiation()

    /**
     * ```
     * new Foo(bar(), baz())
     * ```
     */
    class Constructor(
            val returnTypeName: TypeName,
            val callProviders: CallProviders) : FactoryProviderInstantiation()

    /**
     * ```
     * foo()
     * ```
     */
    class Binds(
            val providerMethodName: String) : FactoryProviderInstantiation()
}

/**
 * ```
 * (foo(), bar())
 * ```
 */
class CallProviders(
        val providerMethodNames: List<String>)

/**
 * ```
 * Foo foo() {
 *     return spreadable().foo();
 * }
 * ```
 */
class SpreadProviderMethod(
        val name: String,
        val isStatic: Boolean,
        val returnTypeName: TypeName,
        val sourceTypeName: TypeName,
        val sourceProviderMethodName: String,
        val spreadMethodName: String)

/**
 * ```
 * public interface Dependencies {
 *     [ DependencyMethods ]
 * }
 * ```
 */
class Dependencies(
        val className: ClassName,
        val methods: List<DependencyMethod>)

/**
 * ```
 * [ JavaDoc ]
 * [ Qualifier ]
 * String fooString();
 * ```
 */
class DependencyMethod(
        val name: String,
        val returnTypeName: TypeName,
        val qualifier: Qualifier?,
        val javaDoc: DependencyMethodJavaDoc)

/**
 * ```
 * @Named("foo")
 * ```
 */
class Qualifier(val annotation: CompilerAnnotation)

/**
 * ```
 * <ul>
 * Requested from:
 * [ JavaDocMethodLinks ]
 * <ul>
 * ```
 */
class DependencyMethodJavaDoc(
        val requestedFrom: List<JavaDocMethodLink>)

/**
 * ```
 * <li>{@link com.example.Foo#bar(com.example.Baz) }</li>
 * ```
 */
class JavaDocMethodLink(
        val owner: String,
        val methodName: String,
        val parameterTypes: List<String>)

/**
 * ```
 * private static class Objects extends FooScope.Objects {
 *
 *     [ ObjectsAbstractMethods ]
 * }
 * ```
 */
class ObjectsImpl(
        val className: ClassName,
        val superClassName: ClassName,
        val isInterface: Boolean,
        val abstractMethods: List<ObjectsAbstractMethod>)

/**
 * ```
 * @Override
 * ConstructorDep constructorDep() {
 *     throw new UnsupportedOperationException();
 * }
 * ```
 */
class ObjectsAbstractMethod(
        // Required work around https://github.com/square/javapoet/issues/656
        val env: ProcessingEnvironment,
        val overriddenMethod: CompilerMethod)

class TypeName private constructor(private val mirror: TypeMirror) {

    val j: com.squareup.javapoet.TypeName by lazy {
        com.squareup.javapoet.TypeName.get(mirror)
    }

    val kt: com.squareup.kotlinpoet.TypeName by lazy {
        KotlinTypeWorkaround.javaToKotlinType(mirror)
    }

    val className: ClassName by lazy { ClassName.get(j) }

    companion object {

        fun get(mirror: TypeMirror): TypeName {
            return TypeName(mirror)
        }
    }
}

class ClassName private constructor(val j: com.squareup.javapoet.ClassName) {

    val kt: com.squareup.kotlinpoet.ClassName by lazy {
        val className = com.squareup.kotlinpoet.ClassName(
                j.packageName(),
                j.simpleNames().first(),
                *j.simpleNames().drop(1).toTypedArray())
        KotlinTypeWorkaround.javaToKotlinType(className) as com.squareup.kotlinpoet.ClassName
    }

    fun nestedClass(name: String): ClassName {
        return ClassName(j.nestedClass(name))
    }

    companion object {

        fun get(packageName: String, name: String): ClassName {
            val j = com.squareup.javapoet.ClassName.get(packageName, name)
            return ClassName(j)
        }

        fun get(j: com.squareup.javapoet.TypeName): ClassName {
            return ClassName(j as com.squareup.javapoet.ClassName)
        }
    }
}